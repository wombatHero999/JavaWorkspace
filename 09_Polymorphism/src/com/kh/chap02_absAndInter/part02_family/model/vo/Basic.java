package com.kh.chap02_absAndInter.part02_family.model.vo;

public interface Basic {
	/* 
	 * 인터페이스
	 * 
	 *  - 내부적으로 상수 필드와 추상 메소드로만 이루어진 추상클래스의 변형
	 *  - 인터페이스에서 필드는 무조건 "상수필드"이다
	 *  - 인터페이스에서 메소드는 무조건 "추상메소드"이다.
	 *  - 자식클래스에서 반드시 구현해야하는 기능이 존재할 경우 , 인터페이스를 만들어서 상속 시켜준다.
	 *  - 인터페이스는 다중상속(다중구현)을 허용한다.
	 *  - 추상클래스와 다르게 좀더 강한 규칙과 강제성 가진다.
	 * 
	 * 추상클래스와 인터페이스
	 *  1. 공통점
	 *   - 객체생성은 불가하나 참조변수로서 사용이 가능.
	 *   - 상속(구현)하는 클래스에서 추상메소드를 구현하도록 "강제"한다
	 *    
	 *  2. 차이점
	 *   - 추상클래스는 클래스 내에 일반 클래스가 가질수 있는 변수나, 필드들을 사용할 수 있고
	 *     인터페이스는 오직 추상메소드와 상수필드만 정의할 수 있다. 
	 *   
	 *   - 존재하는 목적이 다르다.
	 *     추상클래스는 추상클래스를 상속받아서 기능을 이용하고, 클래스를 "확장"하는데 목적이 있으며
	 *     인터페이스는 클래스의 기능구현을 "강제"하기 위해서 사용된다. 
	 *     즉, 구현을 강제함으로써 인터페이스를 구현한 "구현객체"의 같은 동작을 보장할 수 있다.
	 *  
	 *  extends 와 implements
	 *   - 클래스간에 상속 관계 : 클래스명 extends 클래스명
	 *   - 클래스에서 인터페이스를 구현할때 : 클래스명 implements 인터페이스명, 인터페이스명
	 *   - 인터페이스와 인터페이스간의 상속관계 : 인터페이스명 extends 인터페이스명, 인터페이스명, 인터페이스명.,
	 * */
	
	// 인터페이스에서는 상수 필드만 정의할 수 있다.
	/* public static final */ int num = 10; // 필드 앞에 항상 public static final 예약어가 붙는다

	// 인터페이스는 추상메소드만 정의할 수 있다.
	/* public abstract */ void eat();// 항상 메서드앞에 public abstract가 붙기 때문에 생략 가능
	void sleep();
	
	
	// + 참고사항 +
	// 인터페이스 내부에 기능구현이 가능한 경우
	// 디폴트 메소드. -> 인터페이스의 기본기능을 위해 사용하는 메서드
	default void test() {
		
	}
	
	// static 메소드 -> 인스턴스 생성 없이 사용할 수 있는 메소드
	static void test2() {
		privateStaticVoidMethod();
	}
	
	// private static 메소드
	// 인터페이스를 구현한 클래스에서 사용하기 위한 목적의 메서드.
	// 단독으로 사용되는 경우는 없으며 default메소드나 static메소드와 함께 사용된다.
	private static void privateStaticVoidMethod() {
		
	}
	
}
